"""
快速排序是基于分治法的一种排序算法
空间复杂度： 最坏情况下为 O(n)    平均栈深度为 O(log2n)
时间复杂度： O(nlog2n)
快速排序是所有内部排序算法中平均性能最优的一种排序算法

(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 [2]
(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2]
(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2]
(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 [2]
"""

def quick_sort(ll, low, high):
    """
    :param ll: 列表
    :param low: 最小索引
    :param high: 最大索引
    :return: None
    """
    if low < high - 1:
        point = ll[low]
        i = low
        j = high
        while i < j:
            while i < j and ll[j] >= point:
                j -= 1
            ll[i], ll[j] = ll[j], ll[i]
            while i < j and ll[i] <= point:
                i += 1
            ll[j], ll[i] = ll[i], ll[j]
        ll[i] = point
        quick_sort(ll, low, i-1)
        quick_sort(ll, i+1, high)


ll = [10, 5, 1, 4, 14, 85, 21, 7, 15, 5, 48, 48, 46, 88, 84, 254, 8498, 4984, 5, 51651, 651, 6516, 156, 1651, 651, 61,
      61, 651, 651, 65]
n = len(ll)
quick_sort(ll, 0, n-1)
print(ll)

