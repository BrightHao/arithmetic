#coding=utf-8
"""
题目描述：一个8*8的矩阵，要求从左上角走到右下角，只能向下或者向右走，
        且(0,3)(1,6)(2,1)(2,3)(2,4)(3,5)(4,2)(4,5)(5,3)(5,6)(6,1)(6,5)不可通过，
        问一共有多少种走法？

题目分析：当前格子的总步数应该等于 下面格子的步数总和 + 右边格子的步数总和
         反过来计算，从右下角开始往左上角走；
         最后一行和最后一列的走法，除了不能停留的地方外，都是只有一种走法；
         然后依次往上推，每个格子的走法之和=下面格子+右边格子的走法之和。
"""

def dynamic_path(matrix):
    M = len(matrix)
    N = len(matrix[0])
    # 记录各个格子的走法之和
    res = [[0 for i in range(N)] for i in range(M)]
    # 最后一列和最后一行的都只有一种走法
    for i in range(N):
        res[M-1][i] = 1
    for i in range(M):
        res[i][N-1] = 1
    for i in range(M-2, -1, -1):
        for j in range(N-2, -1, -1):
            if matrix[i][j] == 0:
                res[i][j] = res[i][j+1] + res[i+1][j]
    return res[0][0]

if __name__ == "__main__":
    matrix = [
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [1, 0, 1, 0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 1, 0],
        [0, 1, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0]
    ]
    res = dynamic_path(matrix)
    print(res)
