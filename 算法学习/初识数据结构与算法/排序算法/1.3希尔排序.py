"""
基于直接插入排序的一种算法
1.按照某个步长值将列表分为几个组
2.再将每个组中的数值进行直接插入排序
3.到最后步长为1的时候，即直接对整个列表进行直接插入排序

时间复杂度：当n在某个特定范围，时间复杂度约为O(n^1.3)，最坏的情况下，时间复杂度为O(n^2)
"""
import time

t1 = time.time()
A = [0, 5, 1, 4, 14, 85, 21, 7, 15, 5, 48, 48, 46, 88, 84, 254, 8498, 4984, 5, 51651, 651, 6516, 156, 1651, 651, 61,
     61, 651, 651, 65]
n = len(A)
dk = n // 2  # 分组的步长
num = 0  # 用暂存数字
# 从小到大排序
while dk >= 1:  # 按不同的步长进行分组
    i = dk
    while i < n:
        if A[i] < A[i - dk]:
            num = A[i]  # 暂存这个数字
            j = i - dk  # 遍历数字的前一个数字
            while j >=0 and num < A[j]:  # 如果该组前面的元素较大，则往后挪位
                A[j + dk] = A[j]
                j -= dk
            A[j + dk] = num
        i += 1
    dk //= 2  # 步长每次除以二
print("顺序排列：  ", A)

# 从大到小排序
n = len(A)
dk = n // 2  # 分组的步长
while dk >= 1:  # 按不同的步长进行分组
    i = dk
    while i < n:
        if A[i] > A[i - dk]:
            num = A[i]  # 暂存这个数字
            j = i - dk  # 遍历数字的前一个数字
            while j >= 0 and num > A[j]:  # 如果该组前面的元素较大，则往后挪位
                A[j + dk] = A[j]
                j -= dk
            A[j + dk] = num
        i += 1
    dk //= 2  # 步长每次除以二
print("倒序排列：  ", A)

print("完成时间： ", time.time() - t1)
